<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AftWorld - The Balloon Adventure</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #gameStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #youtubeRedirect {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 300;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        #speechInput {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            width: 200px;
            border-radius: 5px;
            border: 1px solid #ccc;
            z-index: 100;
        }
        #speechRecognition {
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            <h3>Controls:</h3>
            <p>W/A/S/D or Arrow Keys: Move</p>
            <p>Space: Jump</p>
            <p>Mouse: Look around</p>
            <p>Goal: Find the Air Filling Magician to inflate your balloon!</p>
        </div>
        <div id="gameStatus">Air Level: <span id="airLevel">0</span>%</div>
        <div id="gameOverScreen">
            <h2 id="gameOverTitle">Level Complete!</h2>
            <p id="gameOverMessage">You found the Air Filling Magician!</p>
            <button id="nextLevelBtn">Continue to Sky Level</button>
        </div>
        <div id="youtubeRedirect">
            <h2>Congratulations!</h2>
            <p>You've completed AftWorld!</p>
            <p>Say "sub" to continue to the creator's channel</p>
            <input type="text" id="speechInput" placeholder="Say 'sub'">
            <div id="speechRecognition"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state variables
        const GAME_STATE = {
            GROUND_LEVEL: 0,
            SKY_LEVEL: 1,
            COMPLETED: 2
        };
        
        let currentGameState = GAME_STATE.GROUND_LEVEL;
        let airLevel = 0;
        let player;
        let magician;
        let scene, camera, renderer;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let controls;
        let skybox;
        let clouds = [];
        let balloonInflated = false;
        let groundMeshes = [];
        let skyMeshes = [];
        let currentLevelMeshes = [];

        // Initialize game
        function init() {
            // Set up scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // Eye level
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Set up lighting
            setupLighting();
            
            // Set up controls
            setupControls();
            
            // Create ground level environment
            createGroundLevel();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 3, 2);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function setupControls() {
            controls = new PointerLockControls();
            scene.add(controls.getObject());
            
            document.addEventListener('click', function() {
                controls.lock();
            }, false);
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }
        
        function createGroundLevel() {
            // Clear any previous level meshes
            clearLevelMeshes();
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x567d46,
                roughness: 0.8 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            groundMeshes.push(ground);
            
            // Create obstacles and paths
            createObstacles();
            
            // Create balloon player (deflated state)
            createPlayer();
            
            // Create the Air Filling Magician
            createMagician();
            
            // Update current meshes reference
            currentLevelMeshes = groundMeshes;
        }
        
        function createObstacles() {
            // Create some trees
            for (let i = 0; i < 20; i++) {
                const treeX = Math.random() * 80 - 40;
                const treeZ = Math.random() * 80 - 40;
                
                // Don't place trees too close to player start or magician
                if (Math.sqrt(treeX * treeX + treeZ * treeZ) < 5 || 
                    Math.sqrt((treeX - 30) * (treeX - 30) + (treeZ - 30) * (treeZ - 30)) < 8) {
                    continue;
                }
                
                createTree(treeX, 0, treeZ);
            }
            
            // Create some rocks
            for (let i = 0; i < 15; i++) {
                const rockX = Math.random() * 70 - 35;
                const rockZ = Math.random() * 70 - 35;
                
                // Don't place rocks too close to player start or magician
                if (Math.sqrt(rockX * rockX + rockZ * rockZ) < 5 || 
                    Math.sqrt((rockX - 30) * (rockX - 30) + (rockZ - 30) * (rockZ - 30)) < 8) {
                    continue;
                }
                
                createRock(rockX, 0, rockZ);
            }
            
            // Create path hints to the magician
            for (let i = 0; i < 5; i++) {
                const pathMarkerX = i * 6;
                const pathMarkerZ = i * 6;
                
                const pathGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
                const pathMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                const pathMarker = new THREE.Mesh(pathGeometry, pathMaterial);
                pathMarker.position.set(pathMarkerX, 0.05, pathMarkerZ);
                pathMarker.receiveShadow = true;
                scene.add(pathMarker);
                groundMeshes.push(pathMarker);
            }
        }
        
        function createTree(x, y, z) {
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 1, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            groundMeshes.push(trunk);
            
            // Tree top
            const leavesGeometry = new THREE.ConeGeometry(2, 4, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, y + 4, z);
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            scene.add(leaves);
            groundMeshes.push(leaves);
        }
        
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.7 + 0.3, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.9 
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, y + rock.geometry.parameters.radius * 0.8, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
            groundMeshes.push(rock);
        }
        
        function createPlayer() {
            // Create deflated balloon geometry
            const balloonGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            balloonGeometry.scale(1, 0.5, 1); // Flatten to look deflated
            
            const balloonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4040,
                roughness: 0.3,
                metalness: 0.2
            });
            
            player = new THREE.Mesh(balloonGeometry, balloonMaterial);
            player.castShadow = true;
            player.position.set(0, 0.25, 0);
            
            controls.getObject().position.set(0, 1.6, 0);
            
            // Add a string to the balloon
            const stringGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -0.25;
            player.add(string);
            
            scene.add(player);
        }
        
        function createMagician() {
            const magicianGroup = new THREE.Group();
            
            // Magician's body
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            magicianGroup.add(body);
            
            // Magician's head
            const headGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;
            magicianGroup.add(head);
            
            // Magician's hat
            const hatGeometry = new THREE.ConeGeometry(0.5, 1, 8);
            const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 3.1;
            magicianGroup.add(hat);
            
            // Magician's wand
            const wandGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const wandMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const wand = new THREE.Mesh(wandGeometry, wandMaterial);
            wand.position.set(0.8, 1.5, 0);
            wand.rotation.z = -Math.PI / 4;
            magicianGroup.add(wand);
            
            // Wand tip with particles
            const wandTipGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const wandTipMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });
            const wandTip = new THREE.Mesh(wandTipGeometry, wandTipMaterial);
            wandTip.position.set(1.3, 2, 0);
            magicianGroup.add(wandTip);
            
            // Position the magician
            magicianGroup.position.set(30, 0, 30);
            
            scene.add(magicianGroup);
            magician = magicianGroup;
            groundMeshes.push(magicianGroup);
        }
        
        function createSkyLevel() {
            // Clear ground level meshes
            clearLevelMeshes();
            
            // Change background to deeper blue
            scene.background = new THREE.Color(0x1E90FF);
            scene.fog = new THREE.Fog(0x1E90FF, 10, 200);
            
            // Reset player to a fully inflated balloon
            inflatePlayerBalloon();
            player.position.set(0, 20, 0);
            controls.getObject().position.set(0, 20, 0);
            
            // Create clouds
            createClouds();
            
            // Create finishing portal
            createFinishPortal();
            
            // Update current meshes reference
            currentLevelMeshes = skyMeshes;
        }
        
        function inflatePlayerBalloon() {
            // Remove old balloon
            scene.remove(player);
            
            // Create fully inflated balloon
            const balloonGeometry = new THREE.SphereGeometry(1, 32, 32);
            const balloonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4040,
                roughness: 0.1,
                metalness: 0.3
            });
            
            player = new THREE.Mesh(balloonGeometry, balloonMaterial);
            player.castShadow = true;
            
            // Add a string to the balloon
            const stringGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -1;
            player.add(string);
            
            scene.add(player);
            balloonInflated = true;
        }
        
        function createClouds() {
            // Create several clouds at different positions
            for (let i = 0; i < 20; i++) {
                const cloudX = Math.random() * 200 - 100;
                const cloudY = Math.random() * 20 + 10;
                const cloudZ = Math.random() * 200 - 100;
                
                const cloud = createCloud();
                cloud.position.set(cloudX, cloudY, cloudZ);
                scene.add(cloud);
                clouds.push(cloud);
                skyMeshes.push(cloud);
            }
        }
        
        function createCloud() {
            const cloudGroup = new THREE.Group();
            
            // Create multiple sphere geometries to form a cloud
            const numPuffs = 5 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < numPuffs; i++) {
                const puffSize = 1 + Math.random() * 2;
                const puffGeometry = new THREE.SphereGeometry(puffSize, 16, 16);
                const puffMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.9
                });
                const puff = new THREE.Mesh(puffGeometry, puffMaterial);
                
                // Position the puff slightly randomly within the cloud
                puff.position.set(
                    Math.random() * 4 - 2,
                    Math.random() * 2 - 1,
                    Math.random() * 4 - 2
                );
                
                cloudGroup.add(puff);
            }
            
            return cloudGroup;
        }
        
        function createFinishPortal() {
            // Create a glowing portal to mark the finish
            const portalGeometry = new THREE.TorusGeometry(3, 0.5, 16, 32);
            const portalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.8
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(60, 30, 60);
            scene.add(portal);
            skyMeshes.push(portal);
            
            // Add some particle effects
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCnt = 500;
            const posArray = new Float32Array(particlesCnt * 3);
            
            for (let i = 0; i < particlesCnt * 3; i += 3) {
                // Create particles in a torus shape around the portal
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + (Math.random() - 0.5) * 1;
                posArray[i] = 60 + Math.cos(angle) * radius;
                posArray[i+1] = 30 + (Math.random() - 0.5) * 2;
                posArray[i+2] = 60 + Math.sin(angle) * radius;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                color: 0xffffff
            });
            
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
            skyMeshes.push(particlesMesh);
        }
        
        function clearLevelMeshes() {
            // Remove all meshes from the current level
            for (let i = 0; i < currentLevelMeshes.length; i++) {
                scene.remove(currentLevelMeshes[i]);
            }
            currentLevelMeshes = [];
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            switch (event.keyCode) {
                case 38: // up arrow
                case 87: // w
                    moveForward = true;
                    break;
                    
                case 37: // left arrow
                case 65: // a
                    moveLeft = true;
                    break;
                    
                case 40: // down arrow
                case 83: // s
                    moveBackward = true;
                    break;
                    
                case 39: // right arrow
                case 68: // d
                    moveRight = true;
                    break;
                    
                case 32: // space
                    if (canJump === true) {
                        velocity.y += 10;
                    }
                    canJump = false;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.keyCode) {
                case 38: // up arrow
                case 87: // w
                    moveForward = false;
                    break;
                    
                case 37: // left arrow
                case 65: // a
                    moveLeft = false;
                    break;
                    
                case 40: // down arrow
                case 83: // s
                    moveBackward = false;
                    break;
                    
                case 39: // right arrow
                case 68: // d
                    moveRight = false;
                    break;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.isLocked === true) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                
                // Apply gravity and handle movement
                velocity.y -= 9.8 * delta; // Apply gravity
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensure consistent movement in all directions
                
                // Handle movement speed
                const moveSpeed = balloonInflated ? 15.0 : 10.0;
                
                if (moveForward || moveBackward) {
                    velocity.z -= direction.z * moveSpeed * delta;
                }
                if (moveLeft || moveRight) {
                    velocity.x -= direction.x * moveSpeed * delta;
                }
                
                // Apply damping to slow down movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                
                // Update position
                controls.getObject().translateX(-velocity.x * delta);
                controls.getObject().translateY(velocity.y * delta);
                controls.getObject().translateZ(-velocity.z * delta);
                
                // Ground collision detection
                if (currentGameState === GAME_STATE.GROUND_LEVEL) {
                    if (controls.getObject().position.y < 1.6) {
                        velocity.y = 0;
                        controls.getObject().position.y = 1.6;
                        canJump = true;
                    }
                } else if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    // In sky level, allow floating without gravity
                    velocity.y = 0;
                    
                    // Apply a slight upward force
                    controls.getObject().position.y += Math.sin(time * 0.002) * 0.01;
                }
                
                // Update player balloon position to follow camera
                const cameraPosition = controls.getObject().position.clone();
                if (currentGameState === GAME_STATE.GROUND_LEVEL) {
                    // On ground level, balloon follows a bit behind and below
                    cameraPosition.y -= 1.2;
                    cameraPosition.z += 1;
                } else if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    // In sky level, balloon is right in front of camera
                    cameraPosition.y -= 0.5;
                    cameraPosition.z += 2;
                }
                player.position.copy(cameraPosition);
                
                // Check for collision with magician in ground level
                if (currentGameState === GAME_STATE.GROUND_LEVEL && magician) {
                    const distanceToMagician = controls.getObject().position.distanceTo(magician.position);
                    if (distanceToMagician < 5) {
                        // Inflate the balloon gradually
                        if (airLevel < 100) {
                            airLevel += 1;
                            document.getElementById('airLevel').textContent = airLevel;
                            
                            // Gradually inflate the balloon visually
                            const inflationProgress = airLevel / 100;
                            player.scale.y = 0.5 + inflationProgress * 0.5;
                            
                            // Add some particles around the magician for visual effect
                            if (airLevel % 5 === 0) {
                                createMagicParticle(magician.position.x, magician.position.y + 2, magician.position.z);
                            }
                        }
                        
                        // When fully inflated, show the level completion screen
                        if (airLevel >= 100 && !balloonInflated) {
                            showGameOverScreen("Level Complete!", "You found the Air Filling Magician!", "Continue to Sky Level");
                        }
                    }
                }
                
                // Check for collision with finish portal in sky level
                if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    const distanceToPortal = controls.getObject().position.distanceTo(new THREE.Vector3(60, 30, 60));
                    if (distanceToPortal < 5) {
                        // Complete the game
                        currentGameState = GAME_STATE.COMPLETED;
                        showYoutubeRedirect();
                    }
                }
                
                // Move clouds slowly in sky level
                if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    clouds.forEach(cloud => {
                        cloud.position.x += Math.sin(time * 0.001 + cloud.position.z) * 0.02;
                        cloud.position.z += Math.cos(time * 0.001 + cloud.position.x) * 0.02;
                    });
                }
                
                prevTime = time;
            }
            
            renderer.render(scene, camera);
        }
        
        function createMagicParticle(x, y, z) {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Position the particle with some random offset
            particle.position.set(
                x + (Math.random() - 0.5) * 2,
                y + Math.random() * 2,
                z + (Math.random() - 0.5) * 2
            );
            
            scene.add(particle);
            groundMeshes.push(particle);
            
            // Remove the particle after a short time
            setTimeout(() => {
                scene.remove(particle);
                const index = groundMeshes.indexOf(particle);
                if (index > -1) {
                    groundMeshes.splice(index, 1);
                }
            }, 1000);
        }
        
        function showGameOverScreen(title, message, buttonText) {
            controls.unlock();
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('nextLevelBtn').textContent = buttonText;
            document.getElementById('gameOverScreen').style.display = 'block';
            
            document.getElementById('nextLevelBtn').addEventListener('click', function() {
                document.getElementById('gameOverScreen').style.display = 'none';
                currentGameState = GAME_STATE.SKY_LEVEL;
                createSkyLevel();
                controls.lock();
            });
        }
        
        function showYoutubeRedirect() {
            controls.unlock();
            document.getElementById('youtubeRedirect').style.display = 'block';
            
            // Set up the speech input handler
            document.getElementById('speechInput').addEventListener('input', function(e) {
                const input = e.target.value.toLowerCase();
                if (input === "sub") {<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AftWorld - The Balloon Adventure</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #gameStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #youtubeRedirect {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 300;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        #speechInput {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            width: 200px;
            border-radius: 5px;
            border: 1px solid #ccc;
            z-index: 100;
        }
        #speechRecognition {
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            <h3>Controls:</h3>
            <p>W/A/S/D or Arrow Keys: Move</p>
            <p>Space: Jump</p>
            <p>Mouse: Look around</p>
            <p>Goal: Find the Air Filling Magician to inflate your balloon!</p>
        </div>
        <div id="gameStatus">Air Level: <span id="airLevel">0</span>%</div>
        <div id="gameOverScreen">
            <h2 id="gameOverTitle">Level Complete!</h2>
            <p id="gameOverMessage">You found the Air Filling Magician!</p>
            <button id="nextLevelBtn">Continue to Sky Level</button>
        </div>
        <div id="youtubeRedirect">
            <h2>Congratulations!</h2>
            <p>You've completed AftWorld!</p>
            <p>Say "sub" to continue to the creator's channel</p>
            <input type="text" id="speechInput" placeholder="Say 'sub'">
            <div id="speechRecognition"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state variables
        const GAME_STATE = {
            GROUND_LEVEL: 0,
            SKY_LEVEL: 1,
            COMPLETED: 2
        };
        
        let currentGameState = GAME_STATE.GROUND_LEVEL;
        let airLevel = 0;
        let player;
        let magician;
        let scene, camera, renderer;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let controls;
        let skybox;
        let clouds = [];
        let balloonInflated = false;
        let groundMeshes = [];
        let skyMeshes = [];
        let currentLevelMeshes = [];

        // Initialize game
        function init() {
            // Set up scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // Eye level
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Set up lighting
            setupLighting();
            
            // Set up controls
            setupControls();
            
            // Create ground level environment
            createGroundLevel();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 3, 2);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }
        
        function setupControls() {
            controls = new PointerLockControls();
            scene.add(controls.getObject());
            
            document.addEventListener('click', function() {
                controls.lock();
            }, false);
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }
        
        function createGroundLevel() {
            // Clear any previous level meshes
            clearLevelMeshes();
            
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x567d46,
                roughness: 0.8 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            groundMeshes.push(ground);
            
            // Create obstacles and paths
            createObstacles();
            
            // Create balloon player (deflated state)
            createPlayer();
            
            // Create the Air Filling Magician
            createMagician();
            
            // Update current meshes reference
            currentLevelMeshes = groundMeshes;
        }
        
        function createObstacles() {
            // Create some trees
            for (let i = 0; i < 20; i++) {
                const treeX = Math.random() * 80 - 40;
                const treeZ = Math.random() * 80 - 40;
                
                // Don't place trees too close to player start or magician
                if (Math.sqrt(treeX * treeX + treeZ * treeZ) < 5 || 
                    Math.sqrt((treeX - 30) * (treeX - 30) + (treeZ - 30) * (treeZ - 30)) < 8) {
                    continue;
                }
                
                createTree(treeX, 0, treeZ);
            }
            
            // Create some rocks
            for (let i = 0; i < 15; i++) {
                const rockX = Math.random() * 70 - 35;
                const rockZ = Math.random() * 70 - 35;
                
                // Don't place rocks too close to player start or magician
                if (Math.sqrt(rockX * rockX + rockZ * rockZ) < 5 || 
                    Math.sqrt((rockX - 30) * (rockX - 30) + (rockZ - 30) * (rockZ - 30)) < 8) {
                    continue;
                }
                
                createRock(rockX, 0, rockZ);
            }
            
            // Create path hints to the magician
            for (let i = 0; i < 5; i++) {
                const pathMarkerX = i * 6;
                const pathMarkerZ = i * 6;
                
                const pathGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
                const pathMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                const pathMarker = new THREE.Mesh(pathGeometry, pathMaterial);
                pathMarker.position.set(pathMarkerX, 0.05, pathMarkerZ);
                pathMarker.receiveShadow = true;
                scene.add(pathMarker);
                groundMeshes.push(pathMarker);
            }
        }
        
        function createTree(x, y, z) {
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 1, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            groundMeshes.push(trunk);
            
            // Tree top
            const leavesGeometry = new THREE.ConeGeometry(2, 4, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, y + 4, z);
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            scene.add(leaves);
            groundMeshes.push(leaves);
        }
        
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.7 + 0.3, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.9 
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, y + rock.geometry.parameters.radius * 0.8, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
            groundMeshes.push(rock);
        }
        
        function createPlayer() {
            // Create deflated balloon geometry
            const balloonGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            balloonGeometry.scale(1, 0.5, 1); // Flatten to look deflated
            
            const balloonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4040,
                roughness: 0.3,
                metalness: 0.2
            });
            
            player = new THREE.Mesh(balloonGeometry, balloonMaterial);
            player.castShadow = true;
            player.position.set(0, 0.25, 0);
            
            controls.getObject().position.set(0, 1.6, 0);
            
            // Add a string to the balloon
            const stringGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -0.25;
            player.add(string);
            
            scene.add(player);
        }
        
        function createMagician() {
            const magicianGroup = new THREE.Group();
            
            // Magician's body
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            magicianGroup.add(body);
            
            // Magician's head
            const headGeometry = new THREE.SphereGeometry(0.4, 32, 32);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.4;
            magicianGroup.add(head);
            
            // Magician's hat
            const hatGeometry = new THREE.ConeGeometry(0.5, 1, 8);
            const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 3.1;
            magicianGroup.add(hat);
            
            // Magician's wand
            const wandGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const wandMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const wand = new THREE.Mesh(wandGeometry, wandMaterial);
            wand.position.set(0.8, 1.5, 0);
            wand.rotation.z = -Math.PI / 4;
            magicianGroup.add(wand);
            
            // Wand tip with particles
            const wandTipGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const wandTipMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });
            const wandTip = new THREE.Mesh(wandTipGeometry, wandTipMaterial);
            wandTip.position.set(1.3, 2, 0);
            magicianGroup.add(wandTip);
            
            // Position the magician
            magicianGroup.position.set(30, 0, 30);
            
            scene.add(magicianGroup);
            magician = magicianGroup;
            groundMeshes.push(magicianGroup);
        }
        
        function createSkyLevel() {
            // Clear ground level meshes
            clearLevelMeshes();
            
            // Change background to deeper blue
            scene.background = new THREE.Color(0x1E90FF);
            scene.fog = new THREE.Fog(0x1E90FF, 10, 200);
            
            // Reset player to a fully inflated balloon
            inflatePlayerBalloon();
            player.position.set(0, 20, 0);
            controls.getObject().position.set(0, 20, 0);
            
            // Create clouds
            createClouds();
            
            // Create finishing portal
            createFinishPortal();
            
            // Update current meshes reference
            currentLevelMeshes = skyMeshes;
        }
        
        function inflatePlayerBalloon() {
            // Remove old balloon
            scene.remove(player);
            
            // Create fully inflated balloon
            const balloonGeometry = new THREE.SphereGeometry(1, 32, 32);
            const balloonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4040,
                roughness: 0.1,
                metalness: 0.3
            });
            
            player = new THREE.Mesh(balloonGeometry, balloonMaterial);
            player.castShadow = true;
            
            // Add a string to the balloon
            const stringGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const stringMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const string = new THREE.Mesh(stringGeometry, stringMaterial);
            string.position.y = -1;
            player.add(string);
            
            scene.add(player);
            balloonInflated = true;
        }
        
        function createClouds() {
            // Create several clouds at different positions
            for (let i = 0; i < 20; i++) {
                const cloudX = Math.random() * 200 - 100;
                const cloudY = Math.random() * 20 + 10;
                const cloudZ = Math.random() * 200 - 100;
                
                const cloud = createCloud();
                cloud.position.set(cloudX, cloudY, cloudZ);
                scene.add(cloud);
                clouds.push(cloud);
                skyMeshes.push(cloud);
            }
        }
        
        function createCloud() {
            const cloudGroup = new THREE.Group();
            
            // Create multiple sphere geometries to form a cloud
            const numPuffs = 5 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < numPuffs; i++) {
                const puffSize = 1 + Math.random() * 2;
                const puffGeometry = new THREE.SphereGeometry(puffSize, 16, 16);
                const puffMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.9
                });
                const puff = new THREE.Mesh(puffGeometry, puffMaterial);
                
                // Position the puff slightly randomly within the cloud
                puff.position.set(
                    Math.random() * 4 - 2,
                    Math.random() * 2 - 1,
                    Math.random() * 4 - 2
                );
                
                cloudGroup.add(puff);
            }
            
            return cloudGroup;
        }
        
        function createFinishPortal() {
            // Create a glowing portal to mark the finish
            const portalGeometry = new THREE.TorusGeometry(3, 0.5, 16, 32);
            const portalMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.8
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(60, 30, 60);
            scene.add(portal);
            skyMeshes.push(portal);
            
            // Add some particle effects
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCnt = 500;
            const posArray = new Float32Array(particlesCnt * 3);
            
            for (let i = 0; i < particlesCnt * 3; i += 3) {
                // Create particles in a torus shape around the portal
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + (Math.random() - 0.5) * 1;
                posArray[i] = 60 + Math.cos(angle) * radius;
                posArray[i+1] = 30 + (Math.random() - 0.5) * 2;
                posArray[i+2] = 60 + Math.sin(angle) * radius;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                color: 0xffffff
            });
            
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
            skyMeshes.push(particlesMesh);
        }
        
        function clearLevelMeshes() {
            // Remove all meshes from the current level
            for (let i = 0; i < currentLevelMeshes.length; i++) {
                scene.remove(currentLevelMeshes[i]);
            }
            currentLevelMeshes = [];
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            switch (event.keyCode) {
                case 38: // up arrow
                case 87: // w
                    moveForward = true;
                    break;
                    
                case 37: // left arrow
                case 65: // a
                    moveLeft = true;
                    break;
                    
                case 40: // down arrow
                case 83: // s
                    moveBackward = true;
                    break;
                    
                case 39: // right arrow
                case 68: // d
                    moveRight = true;
                    break;
                    
                case 32: // space
                    if (canJump === true) {
                        velocity.y += 10;
                    }
                    canJump = false;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.keyCode) {
                case 38: // up arrow
                case 87: // w
                    moveForward = false;
                    break;
                    
                case 37: // left arrow
                case 65: // a
                    moveLeft = false;
                    break;
                    
                case 40: // down arrow
                case 83: // s
                    moveBackward = false;
                    break;
                    
                case 39: // right arrow
                case 68: // d
                    moveRight = false;
                    break;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.isLocked === true) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                
                // Apply gravity and handle movement
                velocity.y -= 9.8 * delta; // Apply gravity
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensure consistent movement in all directions
                
                // Handle movement speed
                const moveSpeed = balloonInflated ? 15.0 : 10.0;
                
                if (moveForward || moveBackward) {
                    velocity.z -= direction.z * moveSpeed * delta;
                }
                if (moveLeft || moveRight) {
                    velocity.x -= direction.x * moveSpeed * delta;
                }
                
                // Apply damping to slow down movement
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                
                // Update position
                controls.getObject().translateX(-velocity.x * delta);
                controls.getObject().translateY(velocity.y * delta);
                controls.getObject().translateZ(-velocity.z * delta);
                
                // Ground collision detection
                if (currentGameState === GAME_STATE.GROUND_LEVEL) {
                    if (controls.getObject().position.y < 1.6) {
                        velocity.y = 0;
                        controls.getObject().position.y = 1.6;
                        canJump = true;
                    }
                } else if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    // In sky level, allow floating without gravity
                    velocity.y = 0;
                    
                    // Apply a slight upward force
                    controls.getObject().position.y += Math.sin(time * 0.002) * 0.01;
                }
                
                // Update player balloon position to follow camera
                const cameraPosition = controls.getObject().position.clone();
                if (currentGameState === GAME_STATE.GROUND_LEVEL) {
                    // On ground level, balloon follows a bit behind and below
                    cameraPosition.y -= 1.2;
                    cameraPosition.z += 1;
                } else if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    // In sky level, balloon is right in front of camera
                    cameraPosition.y -= 0.5;
                    cameraPosition.z += 2;
                }
                player.position.copy(cameraPosition);
                
                // Check for collision with magician in ground level
                if (currentGameState === GAME_STATE.GROUND_LEVEL && magician) {
                    const distanceToMagician = controls.getObject().position.distanceTo(magician.position);
                    if (distanceToMagician < 5) {
                        // Inflate the balloon gradually
                        if (airLevel < 100) {
                            airLevel += 1;
                            document.getElementById('airLevel').textContent = airLevel;
                            
                            // Gradually inflate the balloon visually
                            const inflationProgress = airLevel / 100;
                            player.scale.y = 0.5 + inflationProgress * 0.5;
                            
                            // Add some particles around the magician for visual effect
                            if (airLevel % 5 === 0) {
                                createMagicParticle(magician.position.x, magician.position.y + 2, magician.position.z);
                            }
                        }
                        
                        // When fully inflated, show the level completion screen
                        if (airLevel >= 100 && !balloonInflated) {
                            showGameOverScreen("Level Complete!", "You found the Air Filling Magician!", "Continue to Sky Level");
                        }
                    }
                }
                
                // Check for collision with finish portal in sky level
                if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    const distanceToPortal = controls.getObject().position.distanceTo(new THREE.Vector3(60, 30, 60));
                    if (distanceToPortal < 5) {
                        // Complete the game
                        currentGameState = GAME_STATE.COMPLETED;
                        showYoutubeRedirect();
                    }
                }
                
                // Move clouds slowly in sky level
                if (currentGameState === GAME_STATE.SKY_LEVEL) {
                    clouds.forEach(cloud => {
                        cloud.position.x += Math.sin(time * 0.001 + cloud.position.z) * 0.02;
                        cloud.position.z += Math.cos(time * 0.001 + cloud.position.x) * 0.02;
                    });
                }
                
                prevTime = time;
            }
            
            renderer.render(scene, camera);
        }
        
        function createMagicParticle(x, y, z) {
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Position the particle with some random offset
            particle.position.set(
                x + (Math.random() - 0.5) * 2,
                y + Math.random() * 2,
                z + (Math.random() - 0.5) * 2
            );
            
            scene.add(particle);
            groundMeshes.push(particle);
            
            // Remove the particle after a short time
            setTimeout(() => {
                scene.remove(particle);
                const index = groundMeshes.indexOf(particle);
                if (index > -1) {
                    groundMeshes.splice(index, 1);
                }
            }, 1000);
        }
        
        function showGameOverScreen(title, message, buttonText) {
            controls.unlock();
            document.getElementById('gameOverTitle').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('nextLevelBtn').textContent = buttonText;
            document.getElementById('gameOverScreen').style.display = 'block';
            
            document.getElementById('nextLevelBtn').addEventListener('click', function() {
                document.getElementById('gameOverScreen').style.display = 'none';
                currentGameState = GAME_STATE.SKY_LEVEL;
                createSkyLevel();
                controls.lock();
            });
        }
        
        function showYoutubeRedirect() {
            controls.unlock();
            document.getElementById('youtubeRedirect').style.display = 'block';
            
            // Set up the speech input handler
            document.getElementById('speechInput').addEventListener('input', function(e) {
                const input = e.target.value.toLowerCase();
                if (input === "sub") {
                    // Redirect to Jonathan Aft's YouTube channel
                    window.location.href = "https://youtube.com/@Jonathanaft";
                }
            });
        }
        
        // PointerLockControls implementation
        function PointerLockControls() {
            const scope = this;
            
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            const PI_2 = Math.PI / 2;
            
            const lookObject = new THREE.Object3D();
            
            let isLocked = false;
            
            this.isLocked = isLocked;
            
            this.getObject = function() {
                return lookObject;
            };
            
            this.lock = function() {
                document.body.requestPointerLock();
            };
            
            this.unlock = function() {
                document.exitPointerLock();
            };
            
            const onMouseMove = function(event) {
                if (!scope.isLocked) return;
                
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                euler.setFromQuaternion(lookObject.quaternion);
                
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                
                lookObject.quaternion.setFromEuler(euler);
            };
            
            const onPointerlockChange = function() {
                const currentlyLocked = document.pointerLockElement === document.body;
                
                scope.isLocked = currentlyLocked;
                
                if (currentlyLocked) {
                    document.addEventListener('mousemove', onMouseMove, false);
                } else {
                    document.removeEventListener('mousemove', onMouseMove, false);
                }
            };
            
            const onPointerlockError = function() {
                console.error('PointerLockControls: Unable to use Pointer Lock API');
            };
            
            document.addEventListener('pointerlockchange', onPointerlockChange, false);
            document.addEventListener('pointerlockerror', onPointerlockError, false);
        }
        
        // Start the game on load
        window.addEventListener('load', init);
